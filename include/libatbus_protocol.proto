syntax = "proto3";

package atframework.atbus.protocol;

option go_package = "github.com/atframework/libatbus-go/protocol";
option optimize_for = SPEED;
// option optimize_for = LITE_RUNTIME;
// option optimize_for = CODE_SIZE;
// --cpp_out=lite:,--cpp_out=
option cc_enable_arenas = true;

enum ATBUS_PROTOCOL_CONST {
  option allow_alias = true;
  ATBUS_PROTOCOL_CONST_UNKNOWN = 0;
  ATBUS_PROTOCOL_VERSION = 3;
  ATBUS_PROTOCOL_MINIMAL_VERSION = 3; // minimal protocol version supported
}

enum ATBUS_FORWARD_DATA_FLAG_TYPE {
  FORWARD_DATA_FLAG_NONE = 0;
  // all flags must be power of 2
  FORWARD_DATA_FLAG_REQUIRE_RSP = 1;
}

enum ATBUS_ACCESS_DATA_ALGORITHM_TYPE {
  ATBUS_ACCESS_DATA_ALGORITHM_HMAC_SHA256 = 0;
}

enum ATBUS_CRYPTO_KDF_TYPE {
  ATBUS_CRYPTO_KDF_HKDF_SHA256 = 0;
}

enum ATBUS_CRYPTO_ALGORITHM_TYPE {
  ATBUS_CRYPTO_ALGORITHM_NONE = 0;
  ATBUS_CRYPTO_ALGORITHM_XXTEA = 1;
  ATBUS_CRYPTO_ALGORITHM_AES_128_CBC = 11; // PKCS#7
  ATBUS_CRYPTO_ALGORITHM_AES_192_CBC = 12; // PKCS#7
  ATBUS_CRYPTO_ALGORITHM_AES_256_CBC = 13; // PKCS#7
  ATBUS_CRYPTO_ALGORITHM_AES_128_GCM = 14; // AEAD
  ATBUS_CRYPTO_ALGORITHM_AES_192_GCM = 15; // AEAD
  ATBUS_CRYPTO_ALGORITHM_AES_256_GCM = 16; // AEAD

  ATBUS_CRYPTO_ALGORITHM_CHACHA20 = 31;
  ATBUS_CRYPTO_ALGORITHM_CHACHA20_POLY1305_IETF = 32; // AEAD
  ATBUS_CRYPTO_ALGORITHM_XCHACHA20_POLY1305_IETF = 33; // AEAD
}

enum ATBUS_CRYPTO_KEY_EXCHANGE_TYPE {
  ATBUS_CRYPTO_KEY_EXCHANGE_NONE = 0;
  // golang 标准库只支持ECDH
  ATBUS_CRYPTO_KEY_EXCHANGE_X25519 = 1; // x25519(TLS 1.3推荐)
  ATBUS_CRYPTO_KEY_EXCHANGE_SECP256R1 = 2; // secp256r1, p-256
  ATBUS_CRYPTO_KEY_EXCHANGE_SECP384R1 = 3; // secp384r1, p-384
  ATBUS_CRYPTO_KEY_EXCHANGE_SECP521R1 = 4; // secp521r1, p-521
}

enum ATBUS_COMPRESSION_ALGORITHM_TYPE {
  ATBUS_COMPRESSION_ALGORITHM_NONE = 0;

  ATBUS_COMPRESSION_ALGORITHM_ZSTD = 100;
  ATBUS_COMPRESSION_ALGORITHM_LZ4 = 200;
  ATBUS_COMPRESSION_ALGORITHM_SNAPPY = 300;
  ATBUS_COMPRESSION_ALGORITHM_ZLIB = 400;
}

// 统一压缩等级定义，用于抽象不同压缩算法的压缩强度。
// 枚举值表达语义等级，具体算法参数由实现层映射。
enum ATBUS_COMPRESSION_LEVEL {
  // 默认值：使用各压缩算法的默认推荐配置
  //
  // 典型映射：
  //   zstd   : level 3
  //   lz4    : fast 默认
  //   snappy : 默认配置
  //   zlib   : level 6
  ATBUS_COMPRESSION_LEVEL_DEFAULT = 0;

  // 存储优先：最低 CPU 开销，允许不压缩直接存储
  //
  // 典型映射：
  //   zstd   : level 1（或 0）
  //   lz4    : fast(1)
  //   snappy : 默认配置
  //   zlib   : level 1
  //   none   : 不压缩
  ATBUS_COMPRESSION_LEVEL_STORAGE = 100;

  // 极速压缩，强调最低 CPU 与延迟
  //
  // 典型映射：
  //   zstd   : level -1
  //   lz4    : fast(1)
  //   snappy : 默认配置
  //   zlib   : level 1
  ATBUS_COMPRESSION_LEVEL_FAST = 200;

  // 低 CPU 开销压缩，在性能与压缩率之间轻度折中
  //
  // 典型映射：
  //   zstd   : level 1
  //   lz4    : fast(3)
  //   zlib   : level 3
  ATBUS_COMPRESSION_LEVEL_LOW_CPU = 300;

  // 均衡压缩，作为系统推荐的通用等级
  //
  // 典型映射：
  //   zstd   : level 3
  //   lz4    : fast(6)
  //   zlib   : level 6
  ATBUS_COMPRESSION_LEVEL_BALANCED = 400;

  // 高压缩率，存储优先，允许较高 CPU 成本
  //
  // 典型映射：
  //   zstd   : level 6
  //   lz4    : hc(9)
  //   zlib   : level 9
  ATBUS_COMPRESSION_LEVEL_HIGH_RATIO = 500;

  // 极限压缩，仅适用于冷数据或离线场景
  //
  // 典型映射：
  //   zstd   : level 9 ~ 15
  ATBUS_COMPRESSION_LEVEL_MAX_RATIO = 600;
}

message crypto_handshake_data {
  uint64 sequence = 1; // used to prevent duplication
  ATBUS_CRYPTO_KEY_EXCHANGE_TYPE type = 2;
  repeated ATBUS_CRYPTO_KDF_TYPE kdf_type = 3;
  repeated ATBUS_CRYPTO_ALGORITHM_TYPE algorithms = 4; // available cryptographic algorithms
  // golang 标准库接口不支持生成 TLS 1.2 ECDHE ServerKeyExchange 结构
  // 为了兼容性我们采用 ATBUS_CRYPTO_KEY_EXCHANGE_TYPE 字段标识密钥交换类型，两边配置一致
  // 要求跨语言、跨加密库时需要保证算法都受到支持。
  // 密钥生成算法:
  //   - ATBUS_CRYPTO_KDF_HKDF_SHA256 -> HKDF(sha256(), shared_secret, nil, nil)
  //   - 内容: [KEY][IV]
  bytes public_key = 5;

  // 初始iv size for crypto, must be same as the selected algorithm requirement
  uint32 iv_size = 11;

  // tag length for AEAD
  uint32 tag_size = 21;
}

message custom_command_argv {
  bytes arg = 1;
}

message custom_command_data {
  uint64 from = 1;
  repeated custom_command_argv commands = 2;
  access_data access_key = 3;
}

message forward_data {
  uint64 from = 1;
  uint64 to = 2;
  repeated uint64 router = 3;
  bytes content = 4;
  uint32 flags = 5;
}

message access_data {
  ATBUS_ACCESS_DATA_ALGORITHM_TYPE algorithm = 1;
  int64 timestamp = 2; // unix timestamp

  // 128bits nonce is enough
  // - TLS 1.3: 96 bits
  // - IPSec:   64 bits
  // - JWT:     128 bits
  // - UUID v4: 128 bits
  uint64 nonce1 = 3; // random
  uint64 nonce2 = 4; // random

  // access_token="<timestamp>:<nonce1>-<nonce2>:<register_data.bus_id>:{register_data.crypto_handshake.type}:{hex(sha256_lower_case(register_data.crypto_handshake.public_key))}"
  // access_token="<timestamp>:<nonce1>-<nonce2>:<register_data.bus_id>" (without encryption)
  // access_token="<timestamp>:<nonce1>-<nonce2>:<custom_command_data.from>:{hex(sha256_lower_case(custom_command_data.commands.arg))}"
  // abs(timestamp-current time)<=300
  // access_token must be lower than 32KB
  repeated bytes signature = 9;
}

message channel_data {
  string address = 1;
}

message ping_data {
  int64 time_point = 1;
  crypto_handshake_data crypto_handshake = 2;
}

message register_data {
  uint64 bus_id = 1;
  int32 pid = 2;
  string hostname = 3;
  repeated channel_data channels = 4;
  repeated string supported_channel_schema = 5;
  repeated ATBUS_COMPRESSION_ALGORITHM_TYPE supported_compression_algorithm = 6;
  uint32 flags = 7;
  access_data access_key = 8;
  string hash_code = 10;
  crypto_handshake_data crypto_handshake = 11;
}

message message_head_crypto {
  ATBUS_CRYPTO_ALGORITHM_TYPE algorithm = 1;

  // IV/nonce for crypto, must be unique for each encryption
  // If not set, just used the default rotation/nonce rule of the algorithm
  bytes iv = 2;

  // AAD for AEAD
  bytes aad = 11;
}

message message_head_compression {
  ATBUS_COMPRESSION_ALGORITHM_TYPE type = 1;
  uint64 original_size = 2;
}

message message_head {
  int32 version = 1;
  int32 type = 2;
  sint32 result_code = 3;
  uint64 sequence = 4;
  uint64 source_bus_id = 5;
  message_head_crypto crypto = 6;
  // 加密算法：加密会带字典头部，如果数据很小，加密后反而会扩大尺寸。此时不如不加密。
  // 所以我们每个包是动态决定是否加密的，通过此字段告诉对端如何解包。
  message_head_compression compression = 7;

  // body size without padding
  uint64 body_size = 9;
}

message message_body {
  oneof message_type {
    custom_command_data custom_command_req = 11;
    custom_command_data custom_command_rsp = 12;
    forward_data data_transform_req = 13;
    forward_data data_transform_rsp = 14;
    register_data node_register_req = 17;
    register_data node_register_rsp = 18;
    ping_data node_ping_req = 21;
    ping_data node_pong_rsp = 22;
  }
}
